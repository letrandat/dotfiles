#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

// Core skills to sync (manual invoke only)
const CORE_SKILLS = [
  "using-superpowers",
  "brainstorming",
  "systematic-debugging",
  "verification-before-completion",
  "test-driven-development",
  "writing-plans",
  "executing-plans",
  "dispatching-parallel-agents",
  "subagent-driven-development",
  "requesting-code-review",
  "receiving-code-review",
  "using-git-worktrees",
  "finishing-a-development-branch",
  "writing-skills",
];

// Paths
const SKILLS_DIR = path.join(
  process.env.HOME,
  "workspace/dotfiles/.agent/skills"
);
const WORKFLOWS_DIR = path.join(
  process.env.HOME,
  "workspace/dotfiles/codeium/.codeium/windsurf/global_workflows"
);

function parseSkillFile(filePath) {
  const content = fs.readFileSync(filePath, "utf8");

  // Extract frontmatter
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
  if (!frontmatterMatch) {
    throw new Error(`Invalid skill format: ${filePath}`);
  }

  const frontmatter = frontmatterMatch[1];
  const body = frontmatterMatch[2];

  // Parse frontmatter fields
  const nameMatch = frontmatter.match(/^name:\s*(.+)$/m);
  const descMatch =
    frontmatter.match(/^description:\s*"(.+)"$/m) ||
    frontmatter.match(/^description:\s*(.+)$/m);

  return {
    name: nameMatch ? nameMatch[1].trim() : null,
    description: descMatch ? descMatch[1].trim() : null,
    body: body.trim(),
  };
}

function generateWorkflow(skill) {
  return `---
description: ${skill.description}
auto_execution_mode: 0
---

${skill.body}
`;
}

function syncSkills() {
  // First, sync latest skills from openskills
  console.log("üì• Syncing latest skills from openskills...\n");
  try {
    execSync("openskills sync", { stdio: "inherit" });
    console.log("\n");
  } catch (error) {
    console.error(
      "‚ö†Ô∏è  Warning: openskills sync failed, continuing with existing skills...\n"
    );
  }

  console.log("üîÑ Syncing openskills ‚Üí Windsurf workflows...\n");

  if (!fs.existsSync(SKILLS_DIR)) {
    console.error(`‚ùå Skills directory not found: ${SKILLS_DIR}`);
    process.exit(1);
  }

  if (!fs.existsSync(WORKFLOWS_DIR)) {
    fs.mkdirSync(WORKFLOWS_DIR, { recursive: true });
  }

  let synced = 0;
  let skipped = 0;

  for (const skillName of CORE_SKILLS) {
    const skillPath = path.join(SKILLS_DIR, skillName, "SKILL.md");
    // Prefix all skills with 'superpowers-' to group them in Windsurf and match documentation style
    const workflowPath = path.join(
      WORKFLOWS_DIR,
      `superpowers-${skillName}.md`
    );

    if (!fs.existsSync(skillPath)) {
      console.log(`‚ö†Ô∏è  Skipped ${skillName} (not found)`);
      skipped++;
      continue;
    }

    try {
      const skill = parseSkillFile(skillPath);
      const workflow = generateWorkflow(skill);

      fs.writeFileSync(workflowPath, workflow, "utf8");
      console.log(`‚úÖ Synced ${skillName}`);
      synced++;
    } catch (error) {
      console.error(`‚ùå Failed to sync ${skillName}: ${error.message}`);
      skipped++;
    }
  }

  console.log(`\nüìä Summary: ${synced} synced, ${skipped} skipped`);
  console.log(`üìÅ Workflows: ${WORKFLOWS_DIR}`);

  console.log('\n‚ö†Ô∏è  AGENT REQUIRED: Review synced workflows for:');
  console.log('   - State marker integrity (<!-- WORKFLOW-STATE: ... -->)');
  console.log('   - State transition flow compatibility');
  console.log('   - New workflows requiring state machine updates');
  console.log('   - global_rules.md state transition table accuracy');
}

function promptDownstreamSyncs() {
  const readline = require("readline");
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  const promptAntigravity = () => {
    return new Promise((resolve) => {
      console.log("\nüîó Downstream: Antigravity");
      rl.question("   Sync to Antigravity? [Y/n] ", (answer) => {
        if (answer.toLowerCase() !== "n") {
          console.log("");
          try {
            execSync("openskills-to-antigravity sync", { stdio: "inherit" });
          } catch (error) {
            console.error("‚ö†Ô∏è  Antigravity sync failed:", error.message);
          }
        } else {
          console.log(
            '   Skipped. Run "openskills-to-antigravity sync" manually.'
          );
        }
        resolve();
      });
    });
  };

  const promptGemini = () => {
    return new Promise((resolve) => {
      console.log("\nüîó Downstream: Gemini CLI");
      rl.question("   Sync to Gemini CLI? [Y/n] ", (answer) => {
        if (answer.toLowerCase() !== "n") {
          console.log("");
          try {
            execSync("openskills-to-gemini sync", { stdio: "inherit" });
          } catch (error) {
            console.error("‚ö†Ô∏è  Gemini CLI sync failed:", error.message);
          }
        } else {
          console.log('   Skipped. Run "openskills-to-gemini sync" manually.');
        }
        resolve();
      });
    });
  };

  promptAntigravity()
    .then(() => promptGemini())
    .then(() => rl.close());
}

// CLI
const args = process.argv.slice(2);
const command = args[0];

if (command === "sync") {
  syncSkills();
  promptDownstreamSyncs();
} else {
  console.log(`Usage: openskills-to-windsurf sync`);
  console.log(`\nSyncs core openskills to Windsurf workflows.`);
  console.log(`\nCore skills: ${CORE_SKILLS.join(", ")}`);
  process.exit(1);
}
