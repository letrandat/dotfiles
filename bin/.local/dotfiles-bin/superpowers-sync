#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

// Core skills to sync (manual invoke only)
const CORE_SKILLS = [
  "using-superpowers",
  "brainstorming",
  "systematic-debugging",
  "verification-before-completion",
  "test-driven-development",
  "writing-plans",
  "executing-plans",
  "dispatching-parallel-agents",
  "subagent-driven-development",
  "requesting-code-review",
  "receiving-code-review",
  "using-git-worktrees",
  "finishing-a-development-branch",
  "writing-skills",
];

// Workflow state markers to inject (from state machine design)
// Format: { workflow: { marker: "state-name", insertAfter: "pattern to find" } }
const WORKFLOW_STATE_MARKERS = {
  brainstorming: {
    marker: "brainstorming-complete",
    // Insert after "Use superpowers:writing-plans" section
    insertAfter: /Use superpowers:writing-plans[^\n]*\n/,
  },
  "using-git-worktrees": {
    marker: "worktree-setup-complete",
    // Insert at end of file
    insertAfter: null, // null = append to end
  },
  "writing-plans": {
    marker: "plan-complete",
    // Insert at end of file (after execution handoff)
    insertAfter: null,
  },
  "executing-plans": {
    marker: "execution-complete",
    // Insert before finishing-a-development-branch reference
    insertAfter: null,
  },
  "verification-before-completion": {
    marker: "verification-complete",
    // Insert at end of file
    insertAfter: null,
  },
  "requesting-code-review": {
    marker: "code-review-complete",
    // Insert at end of file
    insertAfter: null,
  },
  "finishing-a-development-branch": {
    marker: "branch-finished",
    // Insert at end of file
    insertAfter: null,
  },
};

// Paths
const SKILLS_DIR = path.join(
  process.env.HOME,
  "workspace/dotfiles/.agent/skills"
);
const WORKFLOWS_DIR = path.join(
  process.env.HOME,
  "workspace/dotfiles/codeium/.codeium/windsurf/global_workflows"
);

function parseSkillFile(filePath) {
  const content = fs.readFileSync(filePath, "utf8");

  // Extract frontmatter
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
  if (!frontmatterMatch) {
    throw new Error(`Invalid skill format: ${filePath}`);
  }

  const frontmatter = frontmatterMatch[1];
  const body = frontmatterMatch[2];

  // Parse frontmatter fields
  const nameMatch = frontmatter.match(/^name:\s*(.+)$/m);
  const descMatch =
    frontmatter.match(/^description:\s*"(.+)"$/m) ||
    frontmatter.match(/^description:\s*(.+)$/m);

  return {
    name: nameMatch ? nameMatch[1].trim() : null,
    description: descMatch ? descMatch[1].trim() : null,
    body: body.trim(),
  };
}

function generateWorkflow(skill) {
  return `---
description: ${skill.description}
auto_execution_mode: 0
---

${skill.body}
`;
}

function injectStateMarkers() {
  console.log("\nüîß Injecting workflow state markers...\n");

  let injected = 0;

  for (const [skillName, config] of Object.entries(WORKFLOW_STATE_MARKERS)) {
    const workflowPath = path.join(
      WORKFLOWS_DIR,
      `superpowers-${skillName}.md`
    );

    if (!fs.existsSync(workflowPath)) {
      console.log(`‚ö†Ô∏è  Skipped ${skillName} (workflow not found)`);
      continue;
    }

    let content = fs.readFileSync(workflowPath, "utf8");

    // Skip if marker already exists
    const markerComment = `<!-- WORKFLOW-STATE: ${config.marker} -->`;
    if (content.includes(markerComment)) {
      console.log(`‚è≠Ô∏è  ${skillName} (marker already present)`);
      continue;
    }

    // Inject marker
    const markerBlock = `\nAfter completing this workflow, emit completion state:\n\n${markerComment}\n`;

    if (config.insertAfter === null) {
      // Append to end of file
      content = content.trimEnd() + "\n" + markerBlock;
    } else {
      // Insert after pattern match
      const match = content.match(config.insertAfter);
      if (match) {
        const insertPos = match.index + match[0].length;
        content =
          content.slice(0, insertPos) + markerBlock + content.slice(insertPos);
      } else {
        // Fallback: append to end
        console.log(`‚ö†Ô∏è  ${skillName}: pattern not found, appending to end`);
        content = content.trimEnd() + "\n" + markerBlock;
      }
    }

    fs.writeFileSync(workflowPath, content, "utf8");
    console.log(`‚úÖ Injected ${skillName} ‚Üí ${config.marker}`);
    injected++;
  }

  console.log(`\nüìä State markers: ${injected} injected`);
}

function syncSkills() {
  // First, sync latest skills from openskills
  console.log("üì• Syncing latest skills from openskills...\n");
  try {
    execSync("openskills sync", { stdio: "inherit" });
    console.log("\n");
  } catch (error) {
    console.error(
      "‚ö†Ô∏è  Warning: openskills sync failed, continuing with existing skills...\n"
    );
  }

  console.log("üîÑ Syncing superpowers ‚Üí Windsurf workflows...\n");

  if (!fs.existsSync(SKILLS_DIR)) {
    console.error(`‚ùå Skills directory not found: ${SKILLS_DIR}`);
    process.exit(1);
  }

  if (!fs.existsSync(WORKFLOWS_DIR)) {
    fs.mkdirSync(WORKFLOWS_DIR, { recursive: true });
  }

  let synced = 0;
  let skipped = 0;

  for (const skillName of CORE_SKILLS) {
    const skillPath = path.join(SKILLS_DIR, skillName, "SKILL.md");
    // Prefix all skills with 'superpowers-' to group them in Windsurf
    const workflowPath = path.join(
      WORKFLOWS_DIR,
      `superpowers-${skillName}.md`
    );

    if (!fs.existsSync(skillPath)) {
      console.log(`‚ö†Ô∏è  Skipped ${skillName} (not found)`);
      skipped++;
      continue;
    }

    try {
      const skill = parseSkillFile(skillPath);
      const workflow = generateWorkflow(skill);

      fs.writeFileSync(workflowPath, workflow, "utf8");
      console.log(`‚úÖ Synced ${skillName}`);
      synced++;
    } catch (error) {
      console.error(`‚ùå Failed to sync ${skillName}: ${error.message}`);
      skipped++;
    }
  }

  console.log(`\nüìä Summary: ${synced} synced, ${skipped} skipped`);
  console.log(`üìÅ Workflows: ${WORKFLOWS_DIR}`);

  console.log("\n‚ö†Ô∏è  AGENT REQUIRED: Review synced workflows for:");
  console.log("   - State marker integrity (<!-- WORKFLOW-STATE: ... -->)");
  console.log("   - State transition flow compatibility");
  console.log("   - New workflows requiring state machine updates");
  console.log("   - global_rules.md state transition table accuracy");
}

// CLI
const args = process.argv.slice(2);
const command = args[0];

if (command === "sync") {
  syncSkills();
  injectStateMarkers();
} else {
  console.log(`Usage: superpowers-sync sync`);
  console.log(`\nSyncs core superpowers to Windsurf workflows.`);
  console.log(`\nCore skills: ${CORE_SKILLS.join(", ")}`);
  process.exit(1);
}
