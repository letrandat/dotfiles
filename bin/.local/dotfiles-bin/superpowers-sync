#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");

// ============================================================================
// CONFIGURATION
// ============================================================================

const CORE_SKILLS = fs
  .readdirSync(path.join(__dirname, "../../..", ".agent/skills"))
  .filter((file) => {
    const skillPath = path.join(__dirname, "../../..", ".agent/skills", file);
    return (
      fs.statSync(skillPath).isDirectory() &&
      fs.existsSync(path.join(skillPath, "SKILL.md"))
    );
  });

const WORKFLOW_STATE_MARKERS = {
  brainstorming: {
    marker: "brainstorming-complete",
    insertAfter: /Use superpowers:writing-plans[^\n]*\n/,
  },
  "using-git-worktrees": {
    marker: "worktree-setup-complete",
    insertAfter: null,
  },
  "writing-plans": { marker: "plan-complete", insertAfter: null },
  "executing-plans": { marker: "execution-complete", insertAfter: null },
  "verification-before-completion": {
    marker: "verification-complete",
    insertAfter: null,
  },
  "requesting-code-review": {
    marker: "code-review-complete",
    insertAfter: null,
  },
  "finishing-a-development-branch": {
    marker: "branch-finished",
    insertAfter: null,
  },
};

// Paths
// Script is at: [REPO_ROOT]/bin/.local/dotfiles-bin/superpowers-sync
// So we need to go up 3 levels: dotfiles-bin -> .local -> bin -> dotfiles
const REPO_ROOT = path.resolve(__dirname, "../../..");
const SKILLS_DIR = path.join(REPO_ROOT, ".agent/skills");
const CONTEXT_DIR = path.join(REPO_ROOT, "docs/agent-context/superpowers");

// ============================================================================
// PLUGINS
// ============================================================================

class Plugin {
  constructor(name) {
    this.name = name;
  }

  log(msg) {
    console.log(`[${this.name}] ${msg}`);
  }

  error(msg) {
    console.error(`‚ùå [${this.name}] ${msg}`);
  }

  preSync() {
    // Setup directories, etc.
  }

  sync(skill) {
    // Sync individual skill
  }

  postSync() {
    // Final tasks
  }

  verify(skills) {
    // Verify sync success
  }
}

class WindsurfPlugin extends Plugin {
  constructor() {
    super("Windsurf");
    this.destDir = path.join(
      REPO_ROOT,
      "codeium/.codeium/windsurf/global_workflows"
    );
  }

  preSync() {
    if (!fs.existsSync(this.destDir)) {
      fs.mkdirSync(this.destDir, { recursive: true });
    }
  }

  sync(skill) {
    const destPath = path.join(this.destDir, `superpowers-${skill.name}.md`);
    const content = `---
description: ${skill.description}
auto_execution_mode: 0
---

${skill.body}
`;
    fs.writeFileSync(destPath, content, "utf8");
    return true;
  }

  postSync() {
    this.injectStateMarkers();
  }

  injectStateMarkers() {
    this.log("Injecting state markers...");
    for (const [skillName, config] of Object.entries(WORKFLOW_STATE_MARKERS)) {
      const workflowPath = path.join(
        this.destDir,
        `superpowers-${skillName}.md`
      );

      if (!fs.existsSync(workflowPath)) {
        continue; // Skip if workflow not synced (e.g. not in CORE_SKILLS)
      }

      let content = fs.readFileSync(workflowPath, "utf8");
      const markerComment = `<!-- WORKFLOW-STATE: ${config.marker} -->`;

      if (content.includes(markerComment)) continue;

      const markerBlock = `\nAfter completing this workflow, emit completion state:\n\n${markerComment}\n`;

      if (config.insertAfter === null) {
        content = content.trimEnd() + "\n" + markerBlock;
      } else {
        const match = content.match(config.insertAfter);
        if (match) {
          const insertPos = match.index + match[0].length;
          content =
            content.slice(0, insertPos) +
            markerBlock +
            content.slice(insertPos);
        } else {
          content = content.trimEnd() + "\n" + markerBlock;
        }
      }
      fs.writeFileSync(workflowPath, content, "utf8");
    }
  }

  verify(skills) {
    this.log("Verifying...");
    let passed = true;
    for (const skillName of skills) {
      const p = path.join(this.destDir, `superpowers-${skillName}.md`);
      if (!fs.existsSync(p)) {
        this.error(
          `Missing workflow: global_workflows/superpowers-${skillName}.md`
        );
        passed = false;
      } else {
        // Content check: state markers
        const content = fs.readFileSync(p, "utf8");
        // Check frontmatter
        if (!content.includes("auto_execution_mode: 0")) {
          this.error(`Missing 'auto_execution_mode: 0' in ${skillName}`);
          passed = false;
        }
        // Check marker if applicable
        if (WORKFLOW_STATE_MARKERS[skillName]) {
          const marker = WORKFLOW_STATE_MARKERS[skillName].marker;
          if (!content.includes(`<!-- WORKFLOW-STATE: ${marker} -->`)) {
            this.error(`Missing state marker '${marker}' in ${skillName}`);
            passed = false;
          }
        }
      }
    }
    return passed;
  }
}

class AntigravityPlugin extends Plugin {
  constructor() {
    super("Antigravity");
    this.destDir = path.join(process.env.HOME, ".agent/workflows");
    this.contextSource = path.join(CONTEXT_DIR, "antigravity");
  }

  preSync() {
    if (!fs.existsSync(this.destDir)) {
      fs.mkdirSync(this.destDir, { recursive: true });
    }
    this.syncContextFiles();
  }

  syncContextFiles() {
    if (fs.existsSync(this.contextSource)) {
      const files = fs.readdirSync(this.contextSource);
      for (const file of files) {
        if (file.endsWith(".md")) {
          fs.copyFileSync(
            path.join(this.contextSource, file),
            path.join(this.destDir, file)
          );
          this.log(`Synced context: ${file}`);
        }
      }
    } else {
      this.error(`Context source not found: ${this.contextSource}`);
    }
  }

  sync(skill) {
    const destPath = path.join(this.destDir, `superpower-${skill.name}.md`);
    // Antigravity can consume raw markdown from SKILL.md (has frontmatter)
    // We just copy the body + frontmatter
    const content = `---
description: ${skill.description}
name: ${skill.name}
---
${skill.body}`;

    fs.writeFileSync(destPath, content, "utf8");
    return true;
  }

  verify(skills) {
    this.log("Verifying...");
    let passed = true;
    // 1. Verify Context
    if (!fs.existsSync(path.join(this.destDir, "agent.md"))) {
      this.error("Missing context file: agent.md");
      passed = false;
    }

    // 2. Verify Skills
    for (const skillName of skills) {
      const p = path.join(this.destDir, `superpower-${skillName}.md`);
      if (!fs.existsSync(p)) {
        this.error(
          `Missing workflow: ~/.agent/workflows/superpower-${skillName}.md`
        );
        passed = false;
      }
      // Could parse file to check naming, but existence is good first step
    }
    return passed;
  }
}

// ============================================================================
// RUNNER
// ============================================================================

function parseSkillFile(filePath) {
  const content = fs.readFileSync(filePath, "utf8");
  const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
  if (!frontmatterMatch) throw new Error(`Invalid format: ${filePath}`);

  const frontmatter = frontmatterMatch[1];
  const nameMatch = frontmatter.match(/^name:\s*(.+)$/m);
  const descMatch =
    frontmatter.match(/^description:\s*"(.+)"$/m) ||
    frontmatter.match(/^description:\s*(.+)$/m);

  return {
    name: nameMatch
      ? nameMatch[1].trim()
      : path.basename(path.dirname(filePath)), // Fallback
    description: descMatch ? descMatch[1].trim() : "No description",
    body: frontmatterMatch[2].trim(),
  };
}

async function main() {
  const args = process.argv.slice(2);
  const mode = args[0]; // 'sync'
  const targetArg = args.find((a) => a.startsWith("--target="));
  const target = targetArg ? targetArg.split("=")[1] : "all";

  if (mode !== "sync") {
    console.log(
      `Usage: superpowers-sync sync [--target=windsurf|antigravity|all]`
    );
    process.exit(1);
  }

  // 1. Update Source
  console.log("üì• Syncing skills from upstream (openskills)...");
  try {
    execSync("openskills sync -y", { stdio: "inherit" });
  } catch (e) {
    console.warn("‚ö†Ô∏è  openskills sync failed, using local cache.");
  }

  // 2. Load Skills
  const skills = [];
  if (!fs.existsSync(SKILLS_DIR)) {
    console.error(`‚ùå Skills directory not found: ${SKILLS_DIR}`);
    process.exit(1);
  }

  for (const skillName of CORE_SKILLS) {
    const p = path.join(SKILLS_DIR, skillName, "SKILL.md");
    if (fs.existsSync(p)) {
      try {
        skills.push(parseSkillFile(p));
      } catch (e) {
        console.error(`‚ö†Ô∏è  Failed to parse ${skillName}: ${e.message}`);
      }
    } else {
      console.warn(`‚ö†Ô∏è  Skill not found: ${skillName}`);
    }
  }

  // 3. Dispatch Plugins
  const plugins = [];
  if (target === "windsurf" || target === "all")
    plugins.push(new WindsurfPlugin());
  if (target === "antigravity" || target === "all")
    plugins.push(new AntigravityPlugin());

  console.log(
    `\nüöÄ Syncing ${skills.length} skills to targets: ${plugins
      .map((p) => p.name)
      .join(", ")}\n`
  );

  let success = true;

  for (const plugin of plugins) {
    plugin.preSync();
    let count = 0;
    for (const skill of skills) {
      if (plugin.sync(skill)) count++;
    }
    plugin.postSync();

    const verifyResult = plugin.verify(skills.map((s) => s.name));
    if (verifyResult) {
      console.log(`‚úÖ [${plugin.name}] Synced & Verified (${count} workflows)`);
    } else {
      console.error(`‚ùå [${plugin.name}] Verification FAILED`);
      success = false;
    }
  }

  if (!success) process.exit(1);
}

main();
