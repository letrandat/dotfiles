{
  // workbench
  // https://code.visualstudio.com/api/extension-capabilities/extending-workbench
  "workbench.colorTheme": "Visual Studio Light",
  "workbench.iconTheme": "material-icon-theme",
  "workbench.preferredDarkColorTheme": "Visual Studio Dark",
  "workbench.preferredLightColorTheme": "Visual Studio Light",

  // window settings
  "window.openFoldersInNewWindow": "off",
  "window.autoDetectColorScheme": true,

  // Editor Settings
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.formatOnSave": false,
  "editor.lineNumbers": "relative",
  "workbench.editor.showTabs": "none",
  "editor.rulers": [100],
  // Enable bracket pair colorization for better readability
  "editor.bracketPairColorization.enabled": true,
  // Show vertical lines for bracket pairs
  "editor.guides.bracketPairs": true,
  // Configure minimap for better performance and visibility
  // "editor.minimap.renderCharacters": false,
  // "editor.minimap.scale": 2,
  // I don't use minimap
  "editor.minimap.enabled": false,

  // search
  "search.searchEditor.focusResultsOnSearch": true,
  "search.searchEditor.reusePriorSearchConfiguration": true,
  // files
  "files.trimTrailingWhitespace": true,
  "files.autoSave": "afterDelay",

  // Terminal Configuration
  "terminal.integrated.copyOnSelection": true,
  "terminal.integrated.suggest.enabled": true,
  // Use either the following font for vscode terminal
  // "terminal.integrated.fontFamily": "FiraCode Nerd Font Mono",
  // terminal profiles
  "terminal.integrated.fontFamily": "JetBrainsMono Nerd Font",
  "terminal.integrated.profiles.osx": {
    "vscode-tmux": {
      "path": "zsh",
      "args": ["-c", "~/.config/Code/User/bin/vscode-tmux.sh"],
      "icon": "terminal-tmux"
    }
  },
  "terminal.integrated.defaultProfile.osx": "zsh",

  // languages settings
  "[jsonc]": {},
  "[typescript]": {
    "editor.defaultFormatter": "vscode.typescript-language-features"
  },
  "[java]": {
    "editor.formatOnSave": false
  },
  "[javascript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "[jsonnet]": {
    "editor.defaultFormatter": "Grafana.vscode-jsonnet"
  },
  "jsonnet.languageServer.formatting": {
    "StringStyle": "double"
  },
  // plugins
  // Git Configuration
  "git.openRepositoryInParentFolders": "always",
  "git.autofetch": true,
  "git.verboseCommit": true,
  "git.enableSmartCommit": true,

  // MultiCommand Configuration
  "multiCommand.commands": [
    {
      "command": "extension.multiCommand.maximizeAndFocusActiveEditorGroup",
      "sequence": [
        "workbench.action.focusActiveEditorGroup",
        "workbench.action.maximizeEditorHideSidebar",
        "workbench.action.closePanel"
      ]
    }
  ],

  // Vim Configuration
  // vim.core
  "vim.useSystemClipboard": true,
  "vim.leader": "<space>",
  // Enable and configure yank highlighting
  "vim.highlightedyank.enable": true,
  "vim.highlightedyank.duration": 200,
  // allowing more breathing room when using vim keybindings
  "vim.timeout": 3000,
  // vim.easymotion
  "vim.easymotion": true,
  "vim.easymotionKeys": "hklyuiopnm,qwertzxcvbasdgjf",
  "vim.insertModeKeyBindings": [],
  "vim.visualModeKeyBindingsNonRecursive": [
    // START: Core settings
    // prevent copying the selected text after pasting
    {
      "before": ["p"],
      // p: Paste the text.
      // gv: Reselect the text that was just pasted.
      // y: Yank the reselected text back
      "after": ["p", "g", "v", "y"]
    },
    // END: Core settings
    // START: easymotion
    {
      "before": ["s"], // read: use s to jump to anywhere with easymotion
      "after": ["<leader>", "<leader>", "s"]
    },
    // END: easymotion
    // START: code format
    {
      "before": ["<leader>", "c", "f"],
      "commands": ["editor.action.formatSelection"]
    },
    // END: code format
    // START: LSP support
    // rename symbol
    {
      "before": ["<leader>", "r"],
      "commands": ["editor.action.rename"]
    },
    // refactor is actually [c]ode [a]ction
    {
      "before": ["<leader>", "a"],
      "commands": ["editor.action.refactor"]
    },
    // code source [A]ction like clean up source file
    {
      "before": ["<leader>", "A"],
      "commands": ["editor.action.sourceAction"]
    }
    // END: LSP support
    // START: git
    // END: git
  ],
  "vim.normalModeKeyBindingsNonRecursive": [
    // START: Core settings
    // use vscode undo/redo
    {
      "before": ["u"],
      "commands": ["undo"]
    },
    {
      "before": ["<C-r>"],
      "commands": ["redo"]
    },
    {
      "before": ["Y"], // usage: Y to yank from start to end
      "after": ["y", "$"]
    },
    {
      "before": ["<C-c>"],
      "after": ["c", "i", "w"]
    },
    {
      "before": ["j"], // smooth j over wrapped text
      "after": ["g", "j"]
    },
    {
      "before": ["k"], // smooth k over wrapped text
      "after": ["g", "k"]
    },
    {
      "before": ["Up"],
      "after": ["<C-w>", "k"]
    },
    {
      "before": ["Down"],
      "after": ["<C-w>", "j"]
    },
    {
      "before": ["Left"],
      "after": ["<C-w>", "h"]
    },
    {
      "before": ["Right"],
      "after": ["<C-w>", "l"]
    },
    // Vim UI Configuration
    {
      "before": ["<leader>", "u", "w"],
      "commands": ["editor.action.toggleWordWrap"]
    },
    // search keybindings
    {
      "before": ["<leader>", "s", "k"],
      "commands": ["workbench.action.openGlobalKeybindings"]
    },
    // END: Core settings
    // START: easymotion
    {
      "before": ["s"], // read: use s to jump to anywhere with easymotion
      "after": ["<leader>", "<leader>", "s"]
    },
    // END: easymotion
    // START: code format
    // format the changes only
    {
      "before": ["<leader>", "c", "f"],
      "commands": ["editor.action.formatChanges"]
    },
    // [f]ormat but BIGGER
    {
      "before": ["<leader>", "c", "F"],
      "commands": ["editor.action.formatDocument"]
    },
    // [o]rganize imports
    {
      "before": ["<leader>", "o"],
      "commands": ["editor.action.organizeImports"]
    },
    // END: code format
    {
      "before": ["leader", "e"],
      "commands": ["workbench.view.explorer"]
    },
    // START: files
    // copy [f]ile [f]iles
    {
      "before": ["leader", "f", "f"],
      "commands": ["workbench.action.quickOpen"]
    },
    // copy [f]ile [r]ecent
    {
      "before": ["<leader>", "f", "r"],
      "commands": ["workbench.action.quickOpen"]
    },
    // copy [f]ile [p]ath
    {
      "before": ["<leader>", "f", "p"],
      "commands": ["copyRelativeFilePath"]
    },
    // copy [f]ile [p]ath but BIGGER
    {
      "before": ["<leader>", "f", "P"],
      "commands": ["copyFilePath"]
    },
    // END: files
    // START: buffers
    {
      "before": ["<leader>", "b", "o"],
      "commands": ["workbench.action.closeOtherEditors"]
    },
    {
      "before": ["<leader>", "b", "d"],
      "commands": ["workbench.action.closeActiveEditor"]
    },
    {
      "before": ["<leader>", "w", "v"],
      "commands": ["workbench.action.splitEditorRight"]
    },
    {
      "before": ["<leader>", "w", "s"],
      "commands": ["workbench.action.splitEditorDown"]
    },
    // simulate buffers list in vim
    {
      "before": ["<leader>", ","],
      "commands": ["workbench.action.showAllEditorsByMostRecentlyUsed"]
    },
    // END: buffers
    // START: LSP support
    // gr (go to references)
    {
      "before": ["g", "r"],
      "commands": ["editor.action.goToReferences"]
    },
    // gd (go to definition) is already supported by default
    // gD (go to source definition)
    {
      "before": ["g", "D"],
      "commands": ["typescript.goToSourceDefinition"]
    },
    // gi (go to last insert) is already taken by default
    // gI (go to Implementation)
    {
      "before": ["g", "I"],
      "commands": ["editor.action.goToImplementation"]
    },
    // gf (go to f) is similar to gd
    {
      "before": ["g", "f"],
      "after": ["g", "d"]
    },
    // gy (go to t[y]pe definition)
    {
      "before": ["g", "y"],
      "commands": ["editor.action.goToTypeDefinition"]
    },
    // gK (go to params hint)
    {
      "before": ["g", "K"],
      "commands": ["editor.action.triggerParameterHints"]
    },
    // gch (go to [c]all [h]ierachy)
    {
      "before": ["g", "c", "h"],
      "commands": ["editor.showCallHierarchy"]
    },
    // go to prev/next problem in files
    {
      "before": ["[", "e"],
      "commands": ["editor.action.marker.prevInFiles"]
    },
    {
      "before": ["]", "e"],
      "commands": ["editor.action.marker.nextInFiles"]
    },
    // rename symbol
    {
      "before": ["<leader>", "r"],
      "commands": ["editor.action.rename"]
    },
    // refactor is actually [c]ode [a]ction
    {
      "before": ["<leader>", "a"],
      "commands": ["editor.action.refactor"]
    },
    // code source [A]ction like clean up source file
    {
      "before": ["<leader>", "A"],
      "commands": ["editor.action.sourceAction"]
    },
    // go to [s]ymbol in file
    {
      "before": ["<leader>", "s", "s"],
      "commands": ["workbench.action.gotoSymbol"]
    },
    // go to [S]ymbol but bigger, to workspace
    {
      "before": ["<leader>", "s", "S"],
      "commands": ["workbench.action.showAllSymbols"]
    },
    // END: LSP support
    // START: git/lazygit
    {
      "before": ["<leader>", "g", "g"],
      "commands": ["lazygit-vscode.toggle"]
    },
    {
      "before": ["]", "h"],
      "commands": ["workbench.action.editor.nextChange"]
    },
    {
      "before": ["[", "h"],
      "commands": ["workbench.action.editor.previousChange"]
    },
    // END: git/lazygit

    // Tasks Configuration
    // [t]ask [r]un
    {
      "before": ["<leader>", "t", "r"],
      "commands": ["workbench.action.tasks.runTask"]
    },
    // [t]ask rerun last
    {
      "before": ["<leader>", "t", "."],
      "commands": ["workbench.action.tasks.reRunTask"]
    },
    // [t]ask [b]uild
    {
      "before": ["<leader>", "t", "b"],
      "commands": ["workbench.action.tasks.build"]
    },
    // [t]ask [c]onfigure
    {
      "before": ["<leader>", "t", "c"],
      "commands": ["workbench.action.tasks.configureTaskRunner"]
    },
    // [t]ask [g]et running tasks
    {
      "before": ["<leader>", "t", "g"],
      "commands": ["workbench.action.tasks.showTasks"]
    },
    // [t]ask [x] terminate
    {
      "before": ["<leader>", "t", "x"],
      "commands": ["workbench.action.tasks.terminate"]
    },
    // [t]ask [l]og
    {
      "before": ["<leader>", "t", "l"],
      "commands": ["workbench.action.tasks.showLog"]
    },
    // [t]ask [t]est
    {
      "before": ["<leader>", "t", "t"],
      "commands": ["workbench.action.tasks.test"]
    },
    // [t]ask [R]estart
    {
      "before": ["<leader>", "t", "R"],
      "commands": ["workbench.action.tasks.restartTask"]
    }
  ],
  // lazygit-vscode
  "lazygit-vscode.autoMaximizeWindow": true,
  "lazygit-vscode.panels": {
    "sidebar": "hide"
  },
  // github.copilot
  "github.copilot.chat.agent.thinkingTool": true,
  "github.copilot.selectedCompletionModel": "gpt-4o-copilot",
  "github.copilot.chat.commitMessageGeneration.instructions": [],
  "github.copilot.chat.testGeneration.instructions": [],
  "github.copilot.chat.codeGeneration.instructions": [
    {
      "text": "When designing software, practice the 'design it twice' philosophy by exploring at least two, preferably radically different, alternatives for major design decisions. For each design alternative, evaluate its strengths and weaknesses by listing pros and cons. Prioritize how easy the design will be for other parts of the system (higher-level software) to use. After presenting design options, wait for me to choose one (e.g., 'option 1') before implementing code."
    },
    {
      "text": "Comment First: Write comments at the beginning of the development process. Comments should explain aspects of the code that are not immediately clear from the code itself. Effective comments provide information at a different level of detail than the code, either adding precision or enhancing intuition, and should avoid merely restating the code. For a new class, start by writing the class interface comment. Next, write interface comments and signatures for the most important public methods, leaving the method bodies empty. Iterate over these comments until the basic structure is correct. Write declarations and comments for the most important class instance variables. Fill in the bodies of the methods, adding implementation comments as needed. For each new method, write the interface comment before the method body. For instance variables, write the comment when declaring the variable."
    },
    {
      "text": "Naming Conventions. Prioritize Clarity: Names should be easily understood and clearly indicate purpose, even when seen alone. Be Precise: Avoid generic terms; use specific names that convey the entity's value (e.g., numIndexlets, cursorVisible, charIndex). Be Concise: Aim for brevity (ideally 2-3 words) but ensure the name remains clear. Maintain Consistency: Use the identical name for the same concept everywhere in the codebase."
    },
    {
      "text": "Prefer deep modules. Design modules with simple interfaces exposing minimal complexity, like Unix I/O's five basic calls. Provide powerful, hidden functionality within the implementation, concealing significant internal complexity akin to a garbage collector. Design interfaces for common use cases, making frequent operations simple like Unix I/O's default sequential access. Create effective abstractions by omitting unimportant details, showing only necessary information as in file system block allocation."
    },
    {
      "text": "Prioritize Simple Interfaces: When designing code modules or functions, prioritize creating clean, intuitive, and simple interfaces for the users (other parts of the code or developers using your code). Handle complexity internally within the implementation rather than exposing it through the interface, even if this makes the internal code more complex. Avoid Amplifying Complexity: Do not write code that unnecessarily pushes complexity onto the user or caller. For example, handle errors internally where possible rather than forcing the caller to catch numerous exceptions, and limit the use of excessive configuration parameters when reasonable defaults or internal logic can manage behavior."
    },
    // for tests
    {
      "text": "Write simple, focused tests that cover all major functionality and edge cases. Tests should be easy to understand and maintain."
    },
    {
      "text": "Follow DRY principles by reusing common setup and utility methods. Refactor test files if they become too large or complex."
    },
    {
      "text": "Ensure test coverage across all applicable environments (dev, test, prod) while staying focused on the relevant code areas."
    },
    {
      "text": "Maintain existing testing patterns and frameworks unless there's a compelling reason for change. Consider the impact of code changes on existing tests."
    },
    {
      "text": "Keep test files organized and avoid testing unrelated code or introducing unnecessary complexity."
    }
  ],
  "chat.agent.enabled": true,
  "chat.mcp.discovery.enabled": true,
  // mcp servers
  "mcp": {}
}
