{
  // workbench
  // https://code.visualstudio.com/api/extension-capabilities/extending-workbench
  "workbench.colorTheme": "Visual Studio Light",
  "workbench.iconTheme": "material-icon-theme",
  "workbench.preferredDarkColorTheme": "Visual Studio Dark",
  "workbench.preferredLightColorTheme": "Visual Studio Light",
  "workbench.settings.useWeightedKeySearch": true,
  // window
  "window.openFoldersInNewWindow": "on",
  "window.autoDetectColorScheme": true,
  // editor
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.formatOnSave": false,
  "editor.lineNumbers": "relative",
  // files
  "files.trimTrailingWhitespace": true,
  // terminal
  "terminal.integrated.copyOnSelection": true,
  "terminal.integrated.suggest.enabled": true,
  // languages settings
  "[jsonc]": {
    "editor.formatOnSave": false
  },
  "[typescript]": {
    "editor.defaultFormatter": "vscode.typescript-language-features"
  },
  "[java]": {
    "editor.formatOnSave": false
  },
  // plugins
  // vim.core
  "vim.useSystemClipboard": true,
  "vim.leader": "<space>",
  // vim.easymotion
  "vim.easymotion": true,
  "vim.easymotionKeys": "hklyuiopnm,qwertzxcvbasdgjf",
  "vim.normalModeKeyBindingsNonRecursive": [
    {
      "before": ["f"], // read: use f to jump to anywhere with easymotion
      "after": ["<leader>", "<leader>", "<leader>", "j"]
    },
    {
      "before": ["Y"], // usage: Y to yank from start to end
      "after": ["y", "$"]
    },
    {
      "before": ["<leader>", "f"],
      "commands": ["workbench.action.quickOpen"]
    },
    {
      "before": ["<leader>", "b", "o"],
      "commands": ["workbench.action.closeOtherEditors"]
    }
  ],
  // git
  "git.openRepositoryInParentFolders": "always",
  // github.copilot
  "github.copilot.selectedCompletionModel": "gpt-4o-copilot",
  "github.copilot.chat.commitMessageGeneration.instructions": [
    {
      "text": "Follow the Conventional Commits specification to create clear and consistent commit history."
    },
    {
      "text": "Each commit message should start with a type, followed by an optional scope, and a concise description."
    },
    {
      "text": "The type should be one of the following: feat (new feature), fix (bug fix), build (changes affecting build system), chore (other changes), ci (CI configuration changes), docs (documentation changes), perf (performance improvements), refactor (code restructuring), revert (reverting changes), or style (formatting changes)."
    },
    {
      "text": "The scope provides additional context and is enclosed in parentheses (e.g., feat(user))."
    },
    {
      "text": "The description should be a short, imperative summary of the change."
    },
    {
      "text": "Optionally include a more detailed body after a blank line for context."
    },
    {
      "text": "The footer can reference issues or note breaking changes (starting with BREAKING CHANGE:)."
    }
  ],
  "github.copilot.chat.testGeneration.instructions": [
    {
      "text": "Use JUnit 5 and Mockito for Java testing. Include @DisplayName annotations for better readability."
    },
    {
      "text": "Mock data should only be used in tests, never in dev or prod environments."
    },
    {
      "text": "Write simple, focused tests that cover all major functionality and edge cases. Tests should be easy to understand and maintain."
    },
    {
      "text": "Follow DRY principles by reusing common setup and utility methods. Refactor test files if they become too large or complex."
    },
    {
      "text": "Ensure test coverage across all applicable environments (dev, test, prod) while staying focused on the relevant code areas."
    },
    {
      "text": "Maintain existing testing patterns and frameworks unless there's a compelling reason for change. Consider the impact of code changes on existing tests."
    },
    {
      "text": "Keep test files organized and avoid testing unrelated code or introducing unnecessary complexity."
    }
  ],
  "github.copilot.chat.codeGeneration.instructions": [
    {
      "text": "Follow these steps for each interaction:\n1. User Identification:\n   - You should assume that you are interacting with default_user\n   - If you have not identified default_user, proactively try to do so.\n\n2. Memory Retrieval:\n   - Always begin your chat by saying only \"Remembering...\" and retrieve all relevant information from your knowledge graph\n   - Always refer to your knowledge graph as your \"memory\"\n\n3. Memory\n   - While conversing with the user, be attentive to any new information that falls into these categories:\n     a) Basic Identity (age, gender, location, job title, education level, etc.)\n     b) Behaviors (interests, habits, etc.)\n     c) Preferences (communication style, preferred language, etc.)\n     d) Goals (goals, targets, aspirations, etc.)\n     e) Relationships (personal and professional relationships up to 3 degrees of separation)\n\n4. Memory Update:\n   - If any new information was gathered during the interaction, update your memory as follows:\n     a) Create entities for recurring organizations, people, and significant events\n     b) Connect them to the current entities using relations\n     b) Store facts about them as observations"
    },
    {
      "text": "Write simple, clean, and organized solutions. Avoid complexity and keep files under 300 lines of code."
    },
    {
      "text": "Avoid code duplication by leveraging existing functionality in the codebase. When fixing bugs, exhaust existing implementation options before introducing new patterns."
    },
    {
      "text": "Make focused changes that are directly related to the task. Do not modify unrelated code or existing architectural patterns unless specifically instructed."
    },
    {
      "text": "Consider all environments (dev, test, prod) when writing code. Never add stubbing or fake data patterns to production code."
    },
    {
      "text": "Write thorough tests for all major functionality and consider the impact of changes on existing tests and related code areas."
    },
    {
      "text": "Protect sensitive configurations: never overwrite .env files without explicit confirmation."
    },
    // for tests
    {
      "text": "Use JUnit 5 and Mockito for Java testing. Include @DisplayName annotations for better readability."
    },
    {
      "text": "Mock data should only be used in tests, never in dev or prod environments."
    },
    {
      "text": "Write simple, focused tests that cover all major functionality and edge cases. Tests should be easy to understand and maintain."
    },
    {
      "text": "Follow DRY principles by reusing common setup and utility methods. Refactor test files if they become too large or complex."
    },
    {
      "text": "Ensure test coverage across all applicable environments (dev, test, prod) while staying focused on the relevant code areas."
    },
    {
      "text": "Maintain existing testing patterns and frameworks unless there's a compelling reason for change. Consider the impact of code changes on existing tests."
    },
    {
      "text": "Keep test files organized and avoid testing unrelated code or introducing unnecessary complexity."
    }
  ],
  "chat.agent.enabled": true,
  "chat.mcp.discovery.enabled": true,
  // mcp servers
  "mcp": {
    "inputs": [],
    "servers": {
      "mcp": {
        "inputs": [],
        "servers": {
          "sequential-thinking": {
            "command": "npx",
            "args": ["-y", "@modelcontextprotocol/server-sequential-thinking"]
          },
          "memory": {
            "command": "npx",
            "args": ["-y", "@modelcontextprotocol/server-memory"],
            "env": {
              "MEMORY_FILE_PATH": "~/workspace/memory.json"
            }
          }
        }
      }
    }
  }
}
